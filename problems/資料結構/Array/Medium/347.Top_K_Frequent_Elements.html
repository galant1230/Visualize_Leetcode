<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>347. Top K Frequent Elements 視覺化 Dashboard</title>
  <style>
    :root {
      --primary: #007acc; --success: #2ecc71; --warning: #f39c12;
      --danger: #e74c3c; --dark: #2c3e50; --bg: #f4f7f9;
    }
    body { font-family: 'Segoe UI', sans-serif; background: var(--bg); margin: 0; padding: 20px; color: var(--dark); }
    .dashboard { max-width: 1200px; margin: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    
    .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
    .full-width { grid-column: span 2; }
    h2 { margin-top: 0; color: var(--primary); border-bottom: 2px solid #eee; padding-bottom: 10px; font-size: 1.25rem; }
    
    /* 題目與看板 */
    .problem-info { display: grid; grid-template-columns: 1.2fr 1fr; gap: 20px; }
    .example-box { background: #f8f9fa; padding: 12px; border-left: 4px solid var(--warning); font-family: monospace; font-size: 0.85rem; }
    .complexity-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; margin-top: 10px; }
    .complexity-table th, .complexity-table td { border: 1px solid #eee; padding: 6px; text-align: left; }
    .complexity-table th { background: #f1f1f1; }

    /* 控制與視覺化 */
    .controls { display: flex; gap: 10px; margin-bottom: 20px; justify-content: center; align-items: center; flex-wrap: wrap; }
    select, input { padding: 8px 15px; border: 2px solid #ddd; border-radius: 20px; outline: none; }
    button { padding: 8px 20px; border: none; border-radius: 20px; cursor: pointer; background: var(--primary); color: white; font-weight: bold; }
    
    .status-msg { font-weight: bold; color: var(--primary); text-align: center; margin-bottom: 15px; min-height: 1.5rem; }
    .viz-area { display: flex; flex-direction: column; gap: 15px; align-items: center; }
    .item-group { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .num-pill { padding: 5px 12px; background: white; border: 2px solid #ddd; border-radius: 15px; font-weight: bold; }
    .num-pill.active { border-color: var(--warning); background: #fff8e1; transform: scale(1.1); }
    
    /* 字典與桶子 */
    .data-container { display: flex; gap: 20px; width: 100%; justify-content: center; flex-wrap: wrap; }
    .dict-view, .bucket-view { background: #f8f9fa; padding: 15px; border-radius: 8px; border-top: 3px solid var(--primary); min-width: 200px; }
    .bucket-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; border-bottom: 1px inset #eee; }
    .bucket-label { font-weight: bold; color: var(--danger); width: 80px; font-size: 0.8rem; }

    /* 代碼區 */
    .code-window { background: #282c34; color: #abb2bf; padding: 15px; border-radius: 8px; font-family: 'Consolas', monospace; font-size: 0.85rem; line-height: 1.5; min-height: 380px; overflow-y: auto; }
    .line { padding: 1px 10px; border-radius: 4px; border-left: 4px solid transparent; white-space: pre; }
    .line.active { background: #3e4451; border-left-color: var(--success); color: white; }
  </style>
</head>
<body>

<div class="dashboard">
  <div class="card full-width">
    <h2>347. 前 K 個高頻元素 (Top K Frequent Elements)</h2>
    <div class="problem-info">
      <div>
        <p><strong>題目描述：</strong>給定一個整數陣列 <code>nums</code> 和一個整數 <code>k</code>，請回傳其中出現頻率前 <code>k</code> 高的元素。您可以按任意順序返回答案。</p>
        <div class="example-box">
          <b>範例 1：</b><br>
          輸入: nums = [1,1,1,2,2,3], k = 2<br>
          輸出: [1,2]
        </div>
      </div>
      <div>
        <table class="complexity-table">
          <tr><th>解法</th><th>時間複雜度</th><th>空間複雜度</th></tr>
          <tr><td>Sol 1: 字典排序</td><td>O(N log N)</td><td>O(N)</td></tr>
          <tr><td>Sol 2: 簡化排序</td><td>O(N log N)</td><td>O(N)</td></tr>
          <tr><td>Sol 3: 桶排序 (最優)</td><td>O(N)</td><td>O(N)</td></tr>
          <tr><td>Sol 4: 最小堆積</td><td>O(N log K)</td><td>O(N)</td></tr>
        </table>
      </div>
    </div>
  </div>

  <div class="card full-width" style="background: transparent; box-shadow: none; padding: 0;">
    <div class="controls">
      演算法：
      <select id="algoType" onchange="initSim()">
        <option value="1">Sol 1: 字典排序 (count.items)</option>
        <option value="2">Sol 2: lambda/get 排序</option>
        <option value="3">Sol 3: Bucket Sort (桶子)</option>
        <option value="4">Sol 4: Min-Heap (最小堆)</option>
      </select>
      nums: <input type="text" id="inputNums" value="1,1,1,2,2,3" style="width: 150px;">
      k: <input type="number" id="inputK" value="2" style="width: 50px;">
      <button onclick="initSim()">重置</button>
      <button id="nextBtn" onclick="runNextStep()">下一步 (Step)</button>
    </div>
  </div>

  <div class="card full-width">
    <div class="status-msg" id="statusMsg">準備就緒</div>
    <div class="viz-area">
      <div class="item-group" id="numsContainer"></div>
      <div class="data-container">
        <div class="dict-view" id="dictView">字典狀態: {}</div>
        <div class="bucket-view" id="bucketView" style="display:none;"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Python 程式碼實作</h2>
    <div class="code-window" id="codeDisplay"></div>
  </div>

  <div class="card">
    <h2>解題筆記</h2>
    <div id="notesArea" style="font-size: 0.9rem; line-height: 1.6;"></div>
  </div>
</div>

<script>
const configs = {
  1: {
    code: ["count = {}","for num in nums:","    count[num] = 1 + count.get(num, 0)","","result = sorted(count.items(), key=lambda x: x[1], reverse=True)[:k]","answer = [item[0] for item in result]","return answer"],
    notes: "<li>使用 <code>count.items()</code> 會將字典轉成 (元素, 次數) 的元組列表。</li><li><code>key=lambda x: x[1]</code> 代表根據『次數』來排序。</li>"
  },
  2: {
    code: ["freq = defaultdict(int)","for num in nums:","    freq[num] += 1","","ans = sorted(freq, key=freq.get, reverse=True)","return ans[:k]"],
    notes: "<li><code>key=freq.get</code> 是一個巧妙的簡寫，直接拿字典的查詢函式當 key。</li><li><code>lambda x: freq[x]</code> 等價於自定義一個 <code>get_freq(x)</code> 函式。</li>"
  },
  3: {
    code: ["freq = defaultdict(int)","for num in nums:","    freq[num] += 1","","buckets = [[] for _ in range(len(nums) + 1)]","for num, count in freq.items():","    buckets[count].append(num)","","res = []","for count in range(len(nums), 0, -1):","    for num in buckets[count]:","        res.append(num)","        if len(res) == k: return res"],
    notes: "<li>這是最優解 $O(N)$。</li><li>建立一個長度為 $N+1$ 的桶子，索引代表『出現次數』。</li><li>次數最高為 $N$（全部數字都一樣時）。</li>"
  },
  4: {
    code: ["freq = defaultdict(int)","for num in nums:","    freq[num] += 1","","heap = []","for num, count in freq.items():","    heapq.heappush(heap, (count, num))","    if len(heap) > k:","        heapq.heappop(heap)","","return [num for count, num in heap]"],
    notes: "<li>使用最小堆 (Min-Heap) 維持 $K$ 個元素。</li><li>當堆積大小超過 $K$，彈出最小的（頻率最低的）。</li><li>最後剩下的就是頻率最高的前 $K$ 個。</li>"
  }
};

let nums = [], k = 0, currentIdx = 0, freq = {}, finished = false, subStep = 0, bucketData = [];

function initSim() {
  const type = document.getElementById('algoType').value;
  nums = document.getElementById('inputNums').value.split(',').map(n => parseInt(n.trim()));
  k = parseInt(document.getElementById('inputK').value);
  currentIdx = 0; freq = {}; finished = false; subStep = 0;
  document.getElementById('nextBtn').disabled = false;
  document.getElementById('bucketView').style.display = (type == "3") ? "block" : "none";
  
  document.getElementById('codeDisplay').innerHTML = configs[type].code.map((line, idx) => 
    `<div class="line" id="line-${idx}">${line}</div>`
  ).join('');
  document.getElementById('notesArea').innerHTML = `<ul>${configs[type].notes}</ul>`;
  
  renderNums();
  updateDict();
  document.getElementById('bucketView').innerHTML = "";
  document.getElementById('statusMsg').innerText = "準備就緒，點擊下一步開始計數。";
}

function renderNums() {
  document.getElementById('numsContainer').innerHTML = nums.map((n, i) => `<div class="num-pill" id="pill-${i}">${n}</div>`).join('');
}

function updateDict() {
  document.getElementById('dictView').innerHTML = `<b>Hash Map (頻率):</b><br>${JSON.stringify(freq)}`;
}

function runNextStep() {
  const type = document.getElementById('algoType').value;
  const msg = document.getElementById('statusMsg');
  clearLineHighlights();

  // 1. 通用的計數階段
  if (currentIdx < nums.length) {
    highlight(1); highlight(2);
    const n = nums[currentIdx];
    freq[n] = (freq[n] || 0) + 1;
    document.querySelectorAll('.num-pill').forEach(p => p.classList.remove('active'));
    document.getElementById(`pill-${currentIdx}`).classList.add('active');
    updateDict();
    msg.innerText = `正在統計數字 ${n}... 當前頻率: ${freq[n]}`;
    currentIdx++;
    return;
  }

  // 2. 演算法特定階段
  if (type == "1" || type == "2") {
    highlight(4);
    const sortedAns = Object.keys(freq).sort((a,b) => freq[b] - freq[a]);
    msg.innerText = `完成排序！前 ${k} 高頻元素為: ${sortedAns.slice(0,k)}`;
    finished = true;
  } 
  else if (type == "3") { // Bucket Sort
    if (subStep === 0) {
      highlight(4);
      bucketData = Array.from({length: nums.length + 1}, () => []);
      msg.innerText = `建立長度為 ${nums.length + 1} 的空桶子...`;
      subStep = 1;
    } else if (subStep === 1) {
      highlight(5); highlight(6);
      Object.entries(freq).forEach(([num, count]) => bucketData[count].push(num));
      let bucketHTML = "<b>Buckets (索引=次數):</b>";
      bucketData.forEach((b, i) => {
        if (b.length > 0 || i > 0) bucketHTML += `<div class="bucket-row"><span class="bucket-label">次數 ${i}:</span> [${b.join(',')}]</div>`;
      });
      document.getElementById('bucketView').innerHTML = bucketHTML;
      msg.innerText = `將元素根據頻率放入桶子中。`;
      subStep = 2;
    } else {
      highlight(9); highlight(10); highlight(12);
      msg.innerText = `從最高頻桶子開始收集，直到湊齊 ${k} 個元素。`;
      finished = true;
    }
  } 
  else if (type == "4") { // Heap
    highlight(6); highlight(8);
    msg.innerText = `使用最小堆積維護前 ${k} 個高頻元素。`;
    finished = true;
  }

  if (finished) document.getElementById('nextBtn').disabled = true;
}

function highlight(idx) { document.getElementById(`line-${idx}`).classList.add('active'); }
function clearLineHighlights() { document.querySelectorAll('.line').forEach(l => l.classList.remove('active')); }

initSim();
</script>
</body>
</html>