<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Reverse Linked List 終極教學</title>
    <style>
        :root {
            --primary: #2563eb;
            --code-bg: #1e293b;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text-main: #334155;
        }
        body { font-family: 'Inter', system-ui, sans-serif; background: #f1f5f9; padding: 20px; }
        .container { max-width: 1100px; margin: auto; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); }
        
        /* 切換區 */
        .config-row { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .btn-group { display: flex; border: 2px solid #e2e8f0; border-radius: 10px; overflow: hidden; }
        .tab { padding: 10px 20px; border: none; background: white; cursor: pointer; font-weight: 700; transition: 0.3s; }
        .tab.active { background: var(--primary); color: white; }

        /* 動態畫布 */
        .stage { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 15px; height: 380px; position: relative; margin-bottom: 25px; overflow: hidden; }
        .label { position: absolute; font-size: 11px; font-weight: bold; color: #94a3b8; left: 20px; }
        
        .node {
            width: 50px; height: 50px; background: var(--primary); color: white; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; font-weight: bold;
            position: absolute; transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .arrow {
            position: absolute; height: 2px; background: #cbd5e1; transition: all 0.6s; transform-origin: left center;
        }
        .arrow::after {
            content: ''; position: absolute; right: 0; top: -4px; border: 5px solid transparent; border-left-color: #cbd5e1;
        }

        /* 程式碼面板 */
        .grid { display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 20px; }
        .code-panel { background: var(--code-bg); color: #e2e8f0; padding: 20px; border-radius: 12px; font-family: 'Fira Code', monospace; font-size: 13px; min-height: 320px; }
        .line { display: block; border-left: 4px solid transparent; padding-left: 12px; white-space: pre; opacity: 0.4; }
        .active-line { background: #334155; border-left-color: #3b82f6; opacity: 1; }

        .ptr-label { position: absolute; font-size: 10px; padding: 2px 6px; border-radius: 4px; color: white; top: -30px; left: 50%; transform: translateX(-50%); white-space: nowrap; }
        .p-curr { background: var(--warning); }
        .p-prev { background: var(--success); }
        .p-next { background: var(--danger); }

        .controls { text-align: center; margin-top: 20px; }
        button.action-btn { padding: 12px 30px; background: #0f172a; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; }
    </style>
</head>
<body>

<div class="container">
    <h1 style="text-align:center;">Reverse Linked List 終極視覺化</h1>
    
    <div class="config-row">
        <div class="btn-group">
            <button class="tab active" id="lang-py" onclick="setLang('py')">Python</button>
            <button class="tab" id="lang-c" onclick="setLang('c')">C 語言</button>
        </div>
        <div class="btn-group">
            <button class="tab active" id="mode-iter" onclick="setMode('iter')">疊代 (Iteration)</button>
            <button class="tab" id="mode-recur" onclick="setMode('recur')">遞迴 (Recursion)</button>
        </div>
    </div>

    <div class="stage" id="main-stage">
        <div class="label" style="top: 20px;">未處理區域 (ORIGINAL LIST)</div>
        <div class="label" style="top: 220px;">已反轉區域 (NEW LIST)</div>
        <div id="elements-container"></div>
    </div>

    <div class="grid">
        <div class="code-panel" id="code-box"></div>
        <div style="background: #fff; border: 1px solid #e2e8f0; padding: 20px; border-radius: 12px;">
            <h4 id="step-title" style="margin:0; color:var(--primary);">狀態說明</h4>
            <p id="step-desc" style="font-size: 0.9rem; color: #64748b; margin-bottom: 20px;">點擊下一步開始模擬。</p>
            <div style="font-size: 0.85rem;">
                <strong>時間複雜度:</strong> 180°C O(n)<br>
                <strong>空間複雜度:</strong> <span id="space-comp">O(1)</span>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="action-btn" onclick="resetSim()" style="background:#64748b; margin-right:10px;">重置</button>
        <button class="action-btn" onclick="runStep()" id="step-btn">下一步 (Step)</button>
    </div>
</div>

<script>
    const data = [1, 2, 3, 4, 5];
    let lang = 'py', mode = 'iter', step = 0;
    let curr = 0, prev = -1, next = -1; // 用於疊代
    let recurIdx = 0, isBacktracking = false; // 用於遞迴

    const codes = {
        py: {
            iter: [`def reverseList(head):`, `    prev, curr = None, head`, `    while curr:`, `        temp = curr.next`, `        curr.next = prev`, `        prev = curr`, `        curr = temp`, `    return prev`],
            recur: [`def reverseList(head):`, `    if not head or not head.next:`, `        return head`, `    newHead = self.reverseList(head.next)`, `    head.next.next = head`, `    head.next = None`, `    return newHead`]
        },
        c: {
            iter: [`struct ListNode* reverseList(struct ListNode* head) {`, `    struct ListNode *prev = NULL, *curr = head;`, `    while (curr) {`, `        struct ListNode* next = curr->next;`, `        curr->next = prev;`, `        prev = curr;`, `        curr = next;`, `    }`, `    return prev;`, `}`],
            recur: [`struct ListNode* reverseList(struct ListNode* head) {`, `    if (!head || !head->next) return head;`, `    struct ListNode* newHead = reverseList(head->next);`, `    head->next->next = head;`, `    head->next = NULL;`, `    return newHead;`, `}`]
        }
    };

    function setLang(l) { lang = l; resetSim(); }
    function setMode(m) { mode = m; resetSim(); }

    function resetSim() {
        step = 0; curr = 0; prev = -1; next = -1; recurIdx = 0; isBacktracking = false;
        document.getElementById('step-btn').disabled = false;
        document.getElementById('space-comp').innerText = mode === 'iter' ? 'O(1)' : 'O(n)';
        updateTabs();
        renderCode();
        renderStage();
        updateText("初始化", "準備開始反轉...");
    }

    function updateTabs() {
        document.getElementById('lang-py').className = 'tab ' + (lang === 'py' ? 'active' : '');
        document.getElementById('lang-c').className = 'tab ' + (lang === 'c' ? 'active' : '');
        document.getElementById('mode-iter').className = 'tab ' + (mode === 'iter' ? 'active' : '');
        document.getElementById('mode-recur').className = 'tab ' + (mode === 'recur' ? 'active' : '');
    }

    function renderCode() {
        document.getElementById('code-box').innerHTML = codes[lang][mode].map((l, i) => `<div class="line" id="l${i}">${l}</div>`).join('');
    }

    function runStep() {
        if (mode === 'iter') {
            const p = step % 4;
            if (curr >= data.length) { updateUI(lang==='py'?7:8, "結束", "回傳反轉後的頭 prev。"); document.getElementById('step-btn').disabled=true; return; }
            if (p === 0) { next = curr + 1; updateUI(3, "暫存", "用 temp 記住下一個點 " + (next < data.length ? data[next] : "NULL")); }
            else if (p === 1) { updateUI(4, "反轉", "將當前節點指回 prev，此時節點會掉落到新串列區域。"); }
            else if (p === 2) { prev = curr; updateUI(5, "移動 Prev", "將新串列的頭移動到當前節點。"); }
            else { curr = next; updateUI(6, "移動 Curr", "移動到下一個待處理節點。"); }
            step++;
        } else {
            // 遞迴模擬
            if (!isBacktracking) {
                if (recurIdx < data.length - 1) { updateUI(3, "遞迴深入", "呼叫下一個節點..."); recurIdx++; }
                else { isBacktracking = true; updateUI(2, "Base Case", "到達末端，節點 " + data[recurIdx] + " 是新的頭。"); }
            } else {
                if (recurIdx > 0) { recurIdx--; updateUI(4, "回溯反轉", "讓後面的節點指回我，並斷開我的原連結。"); }
                else { updateUI(6, "結束", "遞迴結束。"); document.getElementById('step-btn').disabled=true; }
            }
        }
        renderStage();
    }

    function updateUI(line, title, desc) {
        document.querySelectorAll('.line').forEach(l => l.classList.remove('active-line'));
        if(document.getElementById('l'+line)) document.getElementById('l'+line).classList.add('active-line');
        document.getElementById('step-title').innerText = title;
        document.getElementById('step-desc').innerText = desc;
    }

    function renderStage() {
        const container = document.getElementById('elements-container');
        container.innerHTML = '';
        
        data.forEach((val, i) => {
            const node = document.createElement('div');
            node.className = 'node';
            node.innerText = val;
            
            let x, y;
            if (mode === 'iter') {
                const p = step % 4;
                if (i >= curr) { x = 100 + (i * 120); y = 60; }
                else { x = 100 + ((prev - i) * 120); y = 260; node.style.background = 'var(--success)'; }
                // 掉落動畫
                if (i === curr && (p >= 2)) { x = 100; y = 260; }
                
                if (i === curr) node.innerHTML += '<div class="ptr-label p-curr">curr</div>';
                if (i === prev) node.innerHTML += '<div class="ptr-label p-prev">prev</div>';
                if (i === next && i < data.length) node.innerHTML += '<div class="ptr-label p-next">temp</div>';
            } else {
                // 遞迴視覺
                x = 100 + (i * 120);
                y = (i < recurIdx) ? 60 : (isBacktracking ? 260 : 60);
                if (isBacktracking && i >= recurIdx) { node.style.background = 'var(--success)'; }
                if (i === recurIdx) { node.style.background = 'var(--warning)'; node.style.transform = 'scale(1.1)'; node.innerHTML += '<div class="ptr-label p-curr">head</div>'; }
            }

            node.style.left = x + 'px';
            node.style.top = y + 'px';
            container.appendChild(node);

            // 箭頭邏輯
            if (i < data.length - 1) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                let isReversed = (mode === 'iter' ? (i < curr && step % 4 >= 2) : (isBacktracking && i >= recurIdx));
                if (isReversed) {
                    arrow.style.width = '70px'; arrow.style.left = x + 'px'; arrow.style.transform = 'rotate(180deg)'; arrow.style.background = 'var(--success)';
                } else {
                    arrow.style.width = '70px'; arrow.style.left = (x + 50) + 'px'; arrow.style.top = (y + 25) + 'px';
                }
                container.appendChild(arrow);
            }
        });
    }

    function updateText(t, d) {
        document.getElementById('step-title').innerText = t;
        document.getElementById('step-desc').innerText = d;
    }

    resetSim();
</script>
</body>
</html>
